<?php


namespace App\Service;

use App\Entity\BuildingPrototype;
use App\Entity\CauseOfDeath;
use App\Entity\Citizen;
use App\Entity\CitizenHome;
use App\Entity\CitizenHomePrototype;
use App\Entity\CitizenProfession;
use App\Entity\CitizenRankingProxy;
use App\Entity\Forum;
use App\Entity\Gazette;
use App\Entity\HeroicActionPrototype;
use App\Entity\Inventory;
use App\Entity\Season;
use App\Entity\Shoutbox;
use App\Entity\ShoutboxEntry;
use App\Entity\ShoutboxReadMarker;
use App\Entity\Thread;
use App\Entity\ThreadTag;
use App\Entity\Town;
use App\Entity\TownClass;
use App\Entity\TownRankingProxy;
use App\Entity\TownSlotReservation;
use App\Entity\User;
use App\Entity\UserGroup;
use App\Entity\Zone;
use App\Entity\ZonePrototype;
use App\Entity\ZoneTag;
use App\Structures\MyHordesConf;
use App\Structures\TownConf;
use App\Translation\T;
use DateInterval;
use Doctrine\ORM\EntityManagerInterface;
use PHPUnit\Util\Exception;
use Symfony\Contracts\Translation\TranslatorInterface;

class GameFactory
{
    private EntityManagerInterface $entity_manager;
    private GameValidator $validator;
    private Locksmith $locksmith;
    private ItemFactory $item_factory;
    private RandomGenerator $random_generator;
    private InventoryHandler $inventory_handler;
    private CitizenHandler $citizen_handler;
    private UserHandler $user_handler;
    private ZoneHandler $zone_handler;
    private TownHandler $town_handler;
    private LogTemplateHandler $log;
    private ConfMaster $conf;
    private TranslatorInterface $translator;
    private MazeMaker $maze_maker;
    private CrowService $crow;
    private PermissionHandler $perm;
    private TimeKeeperService $timeKeeper;

    const ErrorNone = 0;
    const ErrorTownClosed          = ErrorHelper::BaseTownSelectionErrors + 1;
    const ErrorUserAlreadyInGame   = ErrorHelper::BaseTownSelectionErrors + 2;
    const ErrorUserAlreadyInTown   = ErrorHelper::BaseTownSelectionErrors + 3;
    const ErrorNoDefaultProfession = ErrorHelper::BaseTownSelectionErrors + 4;

    const ErrorTownNoCoaRoom         = ErrorHelper::BaseTownSelectionErrors + 5;
    const ErrorMemberBlocked         = ErrorHelper::BaseTownSelectionErrors + 6;
    private GameProfilerService $gps;

    public function __construct(ConfMaster $conf,
        EntityManagerInterface $em, GameValidator $v, Locksmith $l, ItemFactory $if, TownHandler $th, TimeKeeperService $ts,
        RandomGenerator $rg, InventoryHandler $ih, CitizenHandler $ch, ZoneHandler $zh, LogTemplateHandler $lh,
        TranslatorInterface $translator, MazeMaker $mm, CrowService $crow, PermissionHandler $perm, UserHandler $uh, GameProfilerService $gps)
    {
        $this->entity_manager = $em;
        $this->validator = $v;
        $this->locksmith = $l;
        $this->item_factory = $if;
        $this->random_generator = $rg;
        $this->inventory_handler = $ih;
        $this->citizen_handler = $ch;
        $this->user_handler = $uh;
        $this->zone_handler = $zh;
        $this->town_handler = $th;
        $this->log = $lh;
        $this->conf = $conf;
        $this->translator = $translator;
        $this->maze_maker = $mm;
        $this->crow = $crow;
        $this->perm = $perm;
        $this->gps = $gps;
        $this->timeKeeper = $ts;
    }

    private static array $town_name_snippets = [
        // Modes

        // gsas (gendered subject-adjective-suffic)
        // Plural is generated by adding the characters behind |.
        // To remove characters for a plural form, add one - for each char to remove behind |
        // To replace the plural form entirely, add < behind |

        // combine
        // Randomly selects a sets block, then combines the town name from the inner blocks

        // Opts
        // opt-last:  Two or less components: Use all. 3 or more components, use A+B (80%) or A+B+C (20%).
        // fix-first: Needs 3 or more components, use A+B (40%), A+C (40%) or A+B+C (20%)
        // fix-mid:   Needs 3 or more components, use A+B (40%), B+C (40%) or A+B+C (20%)
        // all:       Always takes all components

        'de' => [
            'mode' => 'gsas',
            'opt' => 'opt-last',
            'genders' => ['f','m','n'],
            'sets' => [
                [   // Adjectives
                    'f' => [ 'Terrorisierende', 'Armselige', 'Verhasste', 'Tapfere', 'Lärmende', 'Drogensüchtige', 'Modrige', 'Gehirnfressende', 'Alkoholisierte ', 'Elende', 'Letzte', 'Ehemalige', 'Ghulverseuchte', 'Verblassende', 'Fragile', 'Angenagte', 'Ignorante', 'Leblose', 'Rührselige', 'Altgediente', 'Wütende', 'Grausige', 'Grausame', 'Himmlische', 'Satanische', 'Mörderische', 'Bunte', 'Mittellose', 'Freundliche', 'Durchgedrehte', 'Böse', 'Atomare', 'Terrorisierende', 'Verrückte', 'Armselige', 'Fröhliche', 'Kreative', 'Graue', 'Stinkende', 'Drogensüchtige', 'Schleichende', 'Modrige', 'Eitrige', 'Letzte', 'Siechende', 'Verdammte', 'Südliche', 'Ehemalige', 'Dunkle', 'Chaotische', 'Alte', 'Blutrote', 'Vielseitige', 'Letzte', 'Verlassene', 'Verrottete', 'Brennende', 'Alkoholisierte' ],
                    'm' => [ 'Hungernder|-', 'Triefender|-', 'Verkommener|-', 'Verdammter|-', 'Verlorener|-', 'Hinterhältiger|-', 'Verlauster|-', 'Kindischer|-', 'Verseuchter|-', 'Modriger|-', 'Schimmliger|-', 'Trockener|-', 'Aussichtsloser|-', 'Eitriger|-', 'Desolater|-', 'Lieblicher|-', 'Blutrünstiger|-', 'Seelenloser|-', 'Hungernder|-', 'Triefender|-', 'Arroganter|-', 'Wasserbefleckter|-', 'Verfluchter|-', 'Modriger|-', 'Schwarzer|-', 'Wackeliger|-', 'Einsamer|-', 'Weinerlicher|-', 'Halluzinierender|-', 'Roter|-', 'Leuchtender|-', 'Heimeliger|-', 'Deprimierter|-', 'Entzugsgefährdeter|-', 'Altbackener|-', 'Dreckiger|-', 'Widerwärtiger|-', 'Schimmliger|-', 'Beliebter|-', 'Bekannter|-', 'Infizierter|-', 'Dunkler|-', 'Rosaroter|-', 'Verfluchter|-', 'Einsamer|-', 'Schrecklicher|-', 'Seelenloser|-' ],
                    'n' => [ 'Eifriges|-', 'Verwesendes|-', 'Unwürdiges|-', 'Modriges|-', 'Traditionelles|-', 'Grausames|-', 'Finsteres|-', 'Fröhliches|-', 'Autoritäres|-', 'Geplagtes|-', 'Subtiles|-', 'Lichtscheues|-', 'Endoplasmatisches|-', 'Rosafarbenes|-', 'Lustiges|-', 'Jährliches|-', 'Billiges|-', 'Geschmolzenes|-', 'Durchgeknalltes|-', 'Bodenloses|-', 'Wasserloses|-', 'Autoritäres|-', 'Neues|-', 'Hübsches|-', 'Kaputtes|-' ],
                    '*' => [],
                ],
                [   // Subjects
                    'f' => [ 'Enklave|n', 'Meute|n', 'Zusammenkunft|en', 'Folterstube|n', 'Überlebende', 'Halluzination|en', 'Zuflucht|en', 'Metropole|n', 'Provinz|en', 'Erinnerung|en', 'Exklave|n', 'Rabenstadt|<Rabenstädte', 'Ghulgebeine', 'Kettensäge|n', 'Hinterlassenschaft|en', 'Hofstadt|<Hofstädte', 'Hoffnung|en', 'Zombiemeute|n', 'Druckerpresse|n', 'Nachricht|en', 'Warnung|en', 'Hölle|n', 'Socke|n', 'Stadt|<Städte', 'Ratte|n', 'Kartoffel|n', 'Statue|n', 'Gastritis', 'Hochburg|en', 'Verdammnis|se', 'Bastion|en', 'Bruderschaft|en', 'Gabel|n', 'Kuchenfabrik|en', 'Lösung|en', 'Zitadelle|n', 'Siedlung|en', 'Ruine|n', 'Überlebende|n', 'Bosheit|en' ],
                    'm' => [ 'Ponyhof|<Ponyhöfe', 'Friedhof|<Friedhöfe', 'Busbahnhof|<Busbahnhöfe', 'Hort|e', 'Ort|e', 'Verräter', 'Saboteur|e', 'Spielplatz|helden', 'Sumpf|streuner', 'Kompost|ierer', 'Aufklärer', 'Bunker', 'Seelenfänger', 'Wasserwaffenbauer', 'Buddler', 'Husten|de', 'Bezirk|e', 'Weiher', 'Häuschenbauer', 'Metzger', 'Poolbauer', 'Ghul|e', 'Seuchenherd|e', 'Altar|e', 'Verschlag|ene', 'Tag|e', 'Kompass|e', 'Wachturm|zinnen', 'Monarch|en', 'Steinewerfer', 'Zombie|s', 'Bonbon|s', 'Uranfresser', 'Bürger', 'Verehrer', 'Meister', 'Trinker', 'Beginn|er', 'Herd|e', 'Satanist|en', 'Pilz|e', 'Einzeller', 'Urinstein|e', 'Stöpsel', 'Kommentar|e', 'Treffpunkt|e', 'Schauplatz|<Schauplätze', 'Stadtname|n', 'Löffel', 'Galgen', 'Federfreund|e', 'Hinterwäldler', 'Angriff|e', 'Namensgeber', 'Seelenfänger', 'Keks|e', 'Jäger', 'Leumund|e', 'Professor|en', 'Einzeller' ],
                    'n' => [ 'Sterben|de', 'Hospital|e', 'Gehirn|e', 'Ghetto|s', 'Kellerloch|asseln', 'Gericht|e', 'Paradies|e', 'Orakel', 'Hämatom|e', 'Armageddon|s', 'Niemandsland|e', 'Exil|e', 'Irrenhaus|insassen', 'Hospiz|e', 'Gelächter', 'Gesindel', 'Spielzeug|e', 'Treffen', 'Opium', 'Iglu|s', 'Dorf|oberste', 'Loch|er', 'Wasserloch|taucher', 'Denkmal|e', 'Städtchen', 'Trainingslager', 'Retikulum', 'Pony|s', 'Spielzeug|e' ],
                    '*' => [],
                ],
                [
                    // Suffixes
                    'f' => [],
                    'm' => [],
                    'n' => [],
                    '*' => ['in der Hölle', 'der Verzweiflung', 'der Gehirnfresser', 'der Sinnlosigkeit', 'der verleugneten Hoffnung', 'der Ruhelosen', 'im Himmel', 'des Grauens', 'des Irrsinns', 'der Unglücklichen', 'der Verstoßenen', 'ohne Entkommen', 'mit Würmern', 'der Hoffnungslosen', 'der Ghule', 'im Ungewissen', 'ohne Reserven', 'mit Käfern', 'der Blutleeren', 'der Wüstenfüchse', 'der Helden', 'der Schmerzgrenze', 'der Postapokalypse', 'des Verderbens', 'der Offenbarung', 'der Apokalypse', 'der Endzeit', 'aus dem Nichts', 'der Nekrosen', 'des Wahnsinns', 'der Schmerzen', 'der Verbannten', 'ohne Hoffnung ', 'der Verdammnis', 'des absoluten Chaos', 'aus glühender Asche', 'ohne Menschenfleisch', 'der Barackenbauer', 'der Verzweifelten', 'des Rabengottes', 'ohne Pläne', 'ohne Führung', 'ohne Wiederkehr', 'der Drogensüchtigen', 'der Wahnsinnigen', 'auf Abwegen', 'im Schatten', 'der Zivilisation', 'im Höllenfeuer', 'am Ende', 'in Raccoon City', 'der Pestilenz', 'der Verblendung', 'der Verirrten', 'der Redseligkeit', 'der Gaukler', 'der Niedergeschlagenheit', 'ohne Wasser', 'am Abgrund', 'im Glashaus', 'von Borderland', 'ohne Wasser ', 'der Zombieforscher', 'im Nirgendwo', 'der Wüste', 'des Zyanid', 'der Zombies', 'der Toten', 'des Untergangs', 'im Müll', 'der Unbelehrbaren', 'des Verderbens', 'der Halluzination', 'der Glückseligkeit', 'mit Komplexen', 'ohne Sonnenschein', 'der Hoffnung', 'der Verkohlten', 'der Sodomie', 'ohne Schokodeko', 'der Epiglottis', 'der Versager', 'von Equestria', 'im Westen', 'der Lustigkeit', 'des Acco', 'der Gehängten', 'von Köchen', 'von Hängungen', 'der Verdammten', 'in der Wüste', 'beim Brunnen', 'am Abgrund', 'für die Massen', 'am Äquator', 'ohne Namen', 'der Welt', 'der Verlassenen', 'hinter dem Wald', 'der Niedlichkeit', 'mit Boden', 'ohne Regen', 'im Schlossgarten', 'der Killerbananen', 'im Süden', 'der Kekse', 'der Namenlosen', 'der Einsiedler', 'für modernes Wohnen', 'der Psychopathen', 'der Hobbysaboteure', 'der Metatiere', 'der Kannibalen', 'des Glücks', 'im Reißverschlußverfahren']
                ]
            ]
        ],
        'en' => [
            'mode' => 'combine',
            'opt' => 'opt-last',
            'sets' => [
                [   // Adjective
                    ['black', 'flaky', 'gangrenous', 'malodorous', 'sweaty', 'murky', 'multicoloured', 'bloody', 'dead', 'sorry', 'abandoned', 'amputated', 'putrid', 'itching', 'deserted', 'damned', 'glum', 'arcane', 'hidden', 'tarnished', 'voodoo', 'weird', 'crepuscular', 'miserable', 'buried', 'lost', 'disappeared', 'entombed', 'pallid', 'vengeful', 'dreaming', 'pale', 'morbid', 'tortuous', 'squalid', 'crazy', 'crowded', 'drab', 'isolated', 'clouded', 'cloudy', 'drab', 'murky', 'somber', 'morose', 'somber', 'dejected', 'vile', 'wicked', 'menacing', 'ominous', 'filthy', 'grotesque', 'misty', 'muddy', 'smoggy', 'stormy', 'strange', 'unsightly', 'crooked', 'alarming', 'fateful', 'macabre', 'plagued', 'screaming', 'crazy', 'appalling', 'ghastly', 'sad', 'devastated', 'distressed', 'hellraising', 'saddened', 'appalled', 'downhearted', 'disheartened', 'tearful', 'boiling', 'broken', 'deep', 'disturbed', 'dusty', 'empty', 'flat', 'gigantic', 'horrible', 'hot', 'mysterious', 'nasty', 'noisy', 'odd', 'old', 'quaint', 'rainy', 'watery', 'wet', 'icy', 'wicked', 'lonely', 'wooden', 'blackened', 'dull', 'melancholic', 'gloomy', 'morose', 'sinister', 'dark', 'taciturn', 'grave', 'bad', 'painful', 'strange', 'rough', 'dishonorable', 'honorable', 'menacing', 'eerie', 'chilling', 'intimidating', 'mediocre', 'infectious', 'endless', 'infernal', 'hellish', 'frightful', 'pitiful', 'ghastly', 'beastly', 'grubby', 'filthy', 'pitiless', 'insanitary', 'unsanitary', 'pathetic', 'monstrous', 'syphilitic', 'barbaric', 'brutal', 'hard', 'fierce', 'heartless', 'invisible', 'slimy', 'unrelenting', 'inflexible', 'inhuman', 'painful', 'bloody', 'savage', 'ignorant', 'uneducated', 'boorish', 'vandal', 'backward', 'noxious', 'dilapidated', 'fossilized', 'backward-looking', 'wrathful', 'wretched', 'reactionary', 'retrograde', 'antique', 'outdated', 'obsolete', 'passed', 'expired', 'dreary', 'nostalgic', 'depressing', 'perverted', 'infected', 'corrupted', 'bribed', 'cracked', 'contaminated', 'paralysed', 'macabre', 'horrifying', 'gruesome', 'vile', 'revolting', 'throbbing', 'dreadful', 'ominous', 'sinister', 'dark', 'rank', 'terrible', 'chilling', 'disgusting', 'eerie', 'ghoulish', 'nasty', 'spooky', 'decrepit', 'shadowy', 'grotesque', 'twisted', 'tempestuous', 'cold', 'hot', 'humid', 'weeping', 'oozing', 'pustulent', 'inferior', 'superior', 'archaic', 'tribal', 'irritable', 'interventionist', 'tormenting', 'tormented', 'totalitarian', 'despotic', 'tormented', 'pushy', 'unbalanced', 'anecdotal', 'pathetic', 'cryptic', 'paralysed', 'obsessed', 'sheltered', 'isolated', 'yellow', 'vengeful', 'fearsome', 'greenish', 'darkened', 'crimson', 'soulful', 'red', 'cursed', 'mouldy', 'uncontrollable', 'battered', 'assaulted', 'shattered', 'strange', 'strict', 'psychotic', 'tense', 'quivering', 'wedded', 'tumescent', 'Deepnight\'s'],
                    // Subject
                    ['tundra', 'steppes', 'steppe', 'pampas', 'plaines', 'plaine', 'prairie', 'prairies', 'reservoir', 'reservoirs', 'trench', 'abyss', 'abysses', 'hole', 'holes', 'station', 'lagoon', 'marina', 'community', 'pit', 'corridor', 'corridors', 'graveyard', 'colony', 'colonies', 'pits', 'village', 'dungeon', 'holes', 'dune', 'dunes', 'mine', 'mines', 'headland', 'shore', 'pits', 'bay', 'beach', 'hamlet', 'hamlets', 'market', 'metropolis', 'parish', 'pueblo', 'pits', 'beaches', 'creeks', 'desert', 'sand', 'sands', 'lake', 'lakes', 'thatch', 'peak', 'peaks', 'plain', 'plains', 'crevice', 'crevasse', 'river', 'rivers', 'stream', 'waterfall', 'wood', 'precipice', 'palisades', 'mound', 'mounds', 'moors', 'cave', 'caves', 'chamber', 'chambers', 'downs', 'foothill', 'knoll', 'mesa', 'mount', 'foothills', 'fell', 'chasm', 'chasms', 'highlands', 'void', 'grave', 'graves', 'canyon', 'canyons', 'valley', 'valleys', 'mountaintop', 'space', 'spaces', 'island', 'islands', 'area', 'areas', 'mass', 'masses', 'arena', 'arenas', 'colossseum', 'colosseums', 'laziness', 'ignorance', 'hope', 'den', 'hill', 'hills', 'facility', 'facilities', 'promenade', 'promenades', 'ground', 'grounds', 'theatre', 'hospital', 'motel', 'hotel', 'inn', 'desert', 'theatres', 'hypogeum', 'roads', 'streets', 'basement', 'house', 'bunker', 'basements', 'cavern', 'caverns', 'theatre', 'tomb', 'tombs', 'mansion', 'district', 'forests', 'woods', 'forest', 'asylum', 'wood', 'shop', 'store', 'sanitorium', 'park', 'school', 'well', 'theatre', 'districts', 'highlands', 'region', 'jungle', 'regions', 'estate', 'lodge', 'cabin', 'ring', 'camp', 'lodge', 'centre', 'lighthouse', 'bay', 'barrack', 'barracks', 'echo', 'endurance', 'slum', 'cliff', 'cliffe', 'fault', 'plantation', 'sinkhole', 'dregs', 'cesspit', 'cove', 'hell', 'port', 'harbour', 'mountain', 'village', 'monolith', 'enclave', 'community', 'athenaeum', 'dam', 'cemetary', 'hall', 'theatre', 'citadel', 'citadelle', 'outpost', 'camp', 'refuge', 'cairn', 'plantation', 'hamlet', 'thoughts', 'tomb', 'frontier', 'frontiere', 'battlements', 'county', 'counties', 'gang', 'gangs', 'junction', 'junctions', 'hideaway', 'hideaways', 'hideout', 'hideouts', 'fort', 'forts', 'land', 'lands', 'crossroad', 'crossroads', 'circle', 'circles', 'structure', 'structures', 'hill', 'hills', 'coast', 'coasts', 'mound', 'mounds', 'hillside', 'hillsides', 'cartel', 'cartels', 'shaft', 'shafts', 'bliss'],
                    // Suffix
                    ['of strings', 'of disappeared scouts', 'of Hordes', 'of the NaturalChemist', 'of Cyclops', 'of the afterlife', 'of sand', 'of darkness', 'of the curved eel', 'of bubblefish', 'of 1000 deaths', 'of hate', 'of shadows', 'of scarecrows', 'of corpses', 'of terror', 'of war', 'of rage', 'of innocents', 'of ill-advised encounters', 'of ghouls', 'of ghosts', 'of vampires', 'of horsemen', 'of psychos', 'of dogs', 'of hounds', 'of beasts', 'of animals', 'of thieves', 'of criminals', 'of knives', 'of crime', 'of skeletons', 'of monsters', 'of forgotten souls', 'of lost souls', 'of the shunned', 'of the living heads', 'of blood', 'of sweat', 'of bacteria', 'of dead rabbits', 'of earthquakes', 'of wolves', 'of nights of darkness', 'of conquerors', 'of hades', 'of the conquered', 'of slaves', 'of the forgotten', 'of the burnt and the blind', 'of the burned', 'of the damned', 'of hunger', 'of hell', 'of fiery wind', 'of the ancient arts', 'of fire', 'of the unspeakable', 'of the dictator', 'of surgeons', 'of flesh', 'of dying flesh', 'of puss', 'of lightning', 'of the raven king', 'of lepers', 'of dreams', 'of temptation', 'of fleas', 'of the beast', 'of painful abcesses', 'of decomposition', 'of idle thoughts', 'of idle hands', 'of the damned', 'of losers', 'of the lost', 'of the crazed', 'of idiots', 'of ever morning', 'of deafening cries', 'of bloody tears', 'of lost hope', 'of aching stomachs', 'of fear', 'of dread', 'of anguish', 'of miracles', 'of nights of horror', 'of terror', 'without purpose', 'of no tomorrow', 'of famine', 'of thirst', 'of slow death', 'without end', 'of gorgons', 'of heartache', 'of sadness', 'of the damned', 'of the headless', 'of birds', 'of the north', 'of the south', 'of neverending pain', 'of the east', 'of the west', 'of the orient', 'of nights without end', 'of crows', 'of ravens', 'of scavengers', 'of maniacs', 'of days without end', 'of witches', 'of the first days', 'of fate', 'of fiery wind', 'of whistling wind', 'of new hope', 'of on high', 'of no evil', 'of eternal rain', 'of the depths', 'of satan', 'of spiders', 'of bees', 'of insects', 'of evil', 'of creeps', 'of howls', 'of monkeys', 'of Dayan', 'of winter', 'of spring', 'of reptiles', 'of corpses', 'of skulls', 'of summer', 'of madness', 'of shrunken heads', 'of flies', 'of the undead', 'of misery', 'of autumn', 'of plagues', 'of killers', 'of murderers', 'of tricks', 'of brutes', 'of irma', 'of the hunted', 'of the uninvited', 'of the unexpected', 'of the turning screw', 'of paradise', 'of cannibals', 'of psychos', 'of sadists', 'of veterans', 'of armageddon', 'of deathly screams', 'of rebels', 'of lost citizens', 'of lost people', 'of madness', 'of the unknown', 'of the anonymous', 'of insanity', 'of the banished', 'without future', 'of insurgents', 'of bloodlust', 'of redemption', 'of weary travellers', 'of the hairy snake', 'of Pocky and Soradobi']
                ]
            ]
        ],
        'fr' => [
            'mode' => 'gsas',
            'opt' => 'opt-last',
            'genders' => ['f','m'],
            'sets' => [
                [   // Subjects
                    'f' => ['Toundra|s', 'Steppe|s', 'Pampa|s', 'Plaine|s', 'Prairie|s', 'Tranchée|s', 'Cavité|s', 'Fosse|s', 'Vallée|s', 'Immensité|s', 'Etendue|s', 'Multitude|s', 'Arène|s', 'Indolence|s', 'Ignorance|s', 'Colline|s', 'Installation|s', 'Promenade|s', 'Surface|s', 'Caverne|s', 'Contrée|s', 'Région|s', 'Dévastation|s', 'Désolation|s', 'Cité|s', 'Caserne|s', 'Rémanence|s', 'Falaise|s', 'Faille|s', 'Crique|s', 'Attraction|s', 'Annexe|s', 'Enclave|s', 'Communauté|s', 'Citadelle|s', 'Plantation|s', 'Gangrène|s', 'Frontière|s', 'Engeance|s', 'Jonction|s', 'Retraite|s', 'Terre|s', 'Croisée|s', 'Orbite|s', 'Structure|s', 'Côte|s', 'Butte|s', 'Coalition|s', 'Paranoïa|s', 'Inconnue|s'],
                    'm' => ['Abîme|s', 'Trou|s', 'Vide|s', 'Fossé|s', 'Canyon|s', 'Espace|s', 'Colisée|s', 'Espoir|s', 'Antre|s', 'Théâtre|s', 'Hypogée|s', 'Souterrain|s', 'Centre|s', 'Echo|s', 'Bidonville|s', 'Gouffre|s', 'Cloaque|s', 'Enfer|s', 'Mont|s', 'Village|s', 'Lieu-dit|s', 'Monolithe|s', 'Cimetière|s', 'Avant-poste|s', 'Camp|s', 'Refuge|s', 'Mystère|s', 'Hameau|x', 'Tombeau|x', 'Comté|s', 'Fort|s', 'Tertre|s', 'Coteau|x', 'Sommet|s', 'Bas-fond|s', 'Songe|s', 'Rempart|s', 'Tumulus'],
                    '*' => [ ],
                ],
                [   // Adjectives
                    'f' => ['noire|s', 'sanglante|s', 'morte|s', 'désolée|s', 'abandonnée|s', 'désertée|s', 'damnée|s', 'obscure|s', 'cachée|s', 'ternie|s', 'enterrée|s', 'perdue|s', 'disparue|s', 'ensevelie|s', 'blafarde|s', 'angoissante|s', 'ravagée|s', 'accablée|s', 'affligée|s', 'attristée|s', 'consternée|s', 'abattue|s', 'découragée|s', 'éplorée|s', 'mauvaise|s', 'brutale|s', 'dure|s', 'inhumaine|s', 'ignorante|s', 'arriérée|s', 'attardée|s', 'croulante|s', 'desuete|s', 'passée|s', 'périmée|s', 'grise|s', 'déprimante|s', 'perverse|s', 'infectée|s', 'gangrenée|s', 'corrompue|s', 'craquelée|s', 'contaminée|s', 'tétanisée|s', 'froide|s', 'chaude|s', 'inférieure|s', 'supérieure|s', 'déséquilibrée|s', 'obsédée|s', 'abritée|s', 'isolée|s', 'jaunie|s', 'maudite|s', 'moisie|s', 'désemparée|s', 'battue|s', 'violée|s', 'inviolée|s', 'anéantie|s', 'tendue|s'],
                    'm' => ['noir|s', 'sanglant|s', 'mort|s', 'désolé|s', 'abandonné|s', 'déserté|s', 'damné|s', 'obscur|s', 'caché|s', 'terni|s', 'enterré|s', 'perdu|s', 'disparu|s', 'enseveli|s', 'blafard|s', 'angoissant|s', 'ravagé|s', 'accablé|s', 'affligé|s', 'attristé|s', 'consterné|s', 'abattu|s', 'découragé|s', 'éploré|s', 'mauvais', 'brutal|-ux', 'dur|s', 'inhumain|s', 'ignorant|s', 'arriéré|s', 'attardé|s', 'croulant|s', 'desuet|s', 'passé|s', 'périmé|s', 'gris', 'déprimant|s', 'pervers', 'infecté|s', 'gangrené|s', 'corrompu|s', 'craquelé|s', 'contaminé|s', 'tétanisé|s', 'froid|s', 'chaud|s', 'inférieur|s', 'supérieur|s', 'déséquilibré|s', 'obsédé|s', 'abrité|s', 'isolé|s', 'jauni|s', 'maudit|s', 'moisi|s', 'désemparé|s', 'battu|s', 'violé|s', 'inviolé|s', 'anéanti|s', 'tendu|s'],
                    '*' => ['antique|s', 'verdâtre|s', 'sanguinaire', 'glauque|s', 'versicolore|s', 'putride|s', 'lugubre', 'crépusculaire|s', 'livide|s', 'sordide', 'funeste|s', 'macabre|s', 'épouvantable|s', 'funèbre|s', 'nocturne|s', 'triste|s', 'atrabilaire|s', 'maussade|s', 'mélancolique|s', 'morne|s', 'morose|s', 'sinistre|s', 'sombre|s', 'taciturne|s', 'grave|s', 'pénible|s', 'rude|s', 'médiocre|s', 'pitoyable|s', 'lamentable|s', 'atroce|s', 'barbare|s', 'féroce|s', 'impitoyable|s', 'implacable|s', 'inflexible|s', 'pénible|s', 'sauvage|s', 'inculte|s', 'rustre|s', 'vandale|s', 'fossile|s', 'passéiste', 'réactionnaire|s', 'rétrograde|s', 'obsolète|s', 'nostalgique|s', 'nordique|s', 'humide|s', 'archaïque|s', 'colérique|s', 'dirigiste|s', 'totalitaire|s', 'despotique|s', 'arriviste|s', 'anecdotique|s', 'pathétique|s', 'pourpre|s', 'rouge|s', 'étrange|s', 'austère|s', 'psychotique|s'],
                ],
                [
                    // Suffixes
                    'f' => [ ],
                    'm' => [ ],
                    '*' => ['des Cordes', 'des Eléments Tristes', 'des Gardiens Effacés', 'des Fouineurs Enterrés', 'des Éclaireurs Disparus', 'des Noëlistes', 'des Hordes', 'de la Chimie Naturelle', 'du Cyclope', 'du Rebond Alpha', 'de l\'Anguille Courbée', 'du Poisson Bulle', 'de McBess le Folâtre', 'de l\'Or Bleu', 'des Hydratones', 'des Lames de Fond', 'de Particules\' Bumdum', 'de Bumdum le Versicolore', 'de Shoot\'em Up Bumdum', 'de Hiko Sharingan', 'de Hiko Twin', 'de Hiko le Fruité', 'de Hk L\'insoumis', 'de Abyssal\' Hk ', 'de Hk le Colorimétrique', 'de Yota le Terrible', 'de Refactor Yota', 'de Warp le Magicien', 'de Warp l\'architecte', 'd\'Irvie Le Terrible', 'd\'HypIrvie', 'd\'Irvie Aux Gommes', 'd\'Ani Le Coloré', 'd\'Ani Enciélé', 'd\'Ani La Peintre', 'd\'Eole notre guide', 'd\'Eole l\'inspiratrice', 'de Shining Gygy', 'de Gyhyom le Fluorescent', 'de Shaolin Kiroukou', 'de Kiroukou le poète', 'de Thinkslow', 'de Whitetigle le juste', 'de Whitetigle', 'de la Vérité de l\'Oméga', 'des États Désunis', 'des Viles Sangsues', 'des Bactéries', 'de la Paix Verte', 'de Threepwood', 'des Norrissiens', 'de Shubi le coquin', 'des Capraphiles', 'des Antivilles', 'des Frutimetières', 'des Parcs Ensevelis', 'des Maux Oubliés', 'des Liners Détruits', 'des Lapins Morts et Futés', 'des Tremblements de Terre', 'de La Marque du Loup', 'de Nô', 'des Ellipses', 'des Demies Vies', 'de LeChuck', 'du Gant de Combat', 'de La Nuit Profonde', 'des Jumeaux Mobiles', 'des Conquis', 'des Tzongres Noirs', 'des Piouz Transis', 'd\'Hadès', 'de Junon Pervertie', 'de Chéloné La Lente', 'des Oubliés', 'des Aveugles Brûlés', 'des Brûlés', 'de l\'Abîme', 'de La Faim', 'des Enfers', 'de Feu', 'du Vent Fou', 'des Arts Ubuesques', 'de l\'Âtre Ancien', 'de l\'Indicible', 'des Grands Anciens', 'de l\'Usurpateur', 'du Plasticien Taquin', 'des Chairs', 'des Peaux', 'du Pus', 'des Eclairs Vacillants', 'des Membres de Pus', 'du Roi Corbeau', 'des Lépreux Morts', 'de Molineux', 'des Pouilleux', 'de La Peste Noire', 'des Abcès Douloureux', 'de Putréfaction', 'des Pensées Futiles', 'de Murakami', 'de l\'Oublié', 'des Perdus', 'de Celles Qui Prient', 'des Idiots', 'du Morne Quotidien', 'des Sanglots Sourds', 'des Larmes de Sang', 'de L\'Obscurité Vaine', 'de La Peur Au Ventre', 'de L\'Angoisse ', 'des Miraculés Bannis', 'des Nuits de l\'Horreur', 'de l\'Effroi', 'sans but', 'sans Lendemain', 'des Affamés', 'de la Soif', 'de la Mort Lente', 'sans Fin', 'des Damnés', 'du nord', 'du sud', 'de l\'est', 'de l\'ouest', 'de l\'orient', 'des Nuits sans Fin', 'des Jours sans Fin', 'des Premiers Jours', 'des Vents Brûlants', 'des Vents Sifflants', 'de la Nouvelle Espérance', 'du Haut', 'du Tréfonds', 'de Twin', 'du Vieux Parc à Fruits', 'de Goatswood', 'de Dunwich', 'de Dizan', 'd\'Arkham', 'de l\'hiver', 'du Printemps', 'de l\'été', 'de l\'automne', 'des Brutes', 'des Sarcasmes', 'd\'Irma', 'des Lapinous', 'des Psychotiques', 'des Sadiques', 'des Vétérans', 'de l\'Armageddon', 'des Insoumis', 'des Citoyens Perdus', 'des Citoyens Anonymes', 'des Anonymes', 'des Bannis', 'des Déshérités', 'sans avenir', 'des Insurgés', 'du Premier Jour', 'du Mistral Perdant', 'de Yukito la cruelle', 'de Yukito la rédemptrice', 'des effusions de sang', 'de la rédemption'],
                ]
            ]
        ],
        'es' => [
            'mode' => 'gsas',
            'opt' => 'fix-first',
            'genders' => ['f','m'],
            'sets' => [
                [
                    // Subjects
                    'f' => ['Tundra|s', 'Estepa|s', 'Corriente|s', 'Pradera|s', 'Arena|s', 'Tumba|s', 'Llanura|s', 'Estepa|s', 'Pampa|s', 'Planicie|s', 'Pradera|s', 'Nirvana|s', 'Zanja|s', 'Fosa|s', 'Gracia|s', 'Mirada|s', 'Cumbre|s', 'Inmensidad|es', 'Indolencia|s', 'Colina|s', 'Piedra|s', 'Ladera|s', 'Comarca|s', 'Región|es', 'Cueva|s', 'Desolación|--ones', 'Falla|s', 'Cloaca|s', 'Cala|s', 'Villa|s', 'Feria|s', 'Ciudadela|s', 'Frontera|s', 'Muralla|-es', 'Alameda|s', 'Aldea|s', 'Boca|s', 'Fuente|s', 'Cuadra|s', 'Pocilga|s', 'Tierra', 'Tierra|s', 'Cruzada', 'Cruzada|s', 'Barriada|s', 'Calle|s', 'Gruta|s', 'Grieta|s', 'Alianza|s', 'Ensenada|s'],
                    'm' => ['Horizonte|s', 'Sendero|s', 'Llano|s', 'Rumore|s', 'Aire|s', 'Barracón|--ones', 'Jardín|--ines', 'Suburbio|s', 'Límite|s', 'Burgo|s', 'Cerro|s', 'Jirón|--ones', 'Cuchitril|es', 'Muro|s', 'Villorrio|s', 'Abismo|s', 'Altar|es', 'Averno|s', 'Hoyo|s', 'Vacío|s', 'Cañón|--ones', 'Valle|s', 'Averno|s', 'Espacio|s', 'Canto|s', 'Rincón|--ones', 'Vergel|es', 'Edén|s', 'Antro|s', 'Recinto|s', 'Paseo|s', 'Teatro|s', 'Subsuelo|s', 'Sitio|s', 'Barrio|s', 'Eco|s', 'Suburbio|s', 'Acantilado|s', 'Precipicio|s', 'Abismo|s', 'Infierno|s', 'Monte|s', 'Caserío|s', 'Monolito|s', 'Enclave|s', 'Cementerio|s', 'Pabellón|--ones', 'Campo|s', 'Refugio|s', 'Montículo|s', 'Misterio|s', 'Sepulcro|s', 'Condado|s', 'Corral|s', 'Fundo|s', 'Arrabal|es', 'Pozo|s', 'Cerro|s', 'Belén|s', 'Fósil|es', 'Prado|s', 'Retiro|s', 'Fuerte|s', 'Santuario|s', 'Paraíso|s', 'Paseo|s', 'Poblado|s', 'Hito|s', 'Paisaje|s', 'Suspiro|s'],
                    '*' => [ ],
                ],
                [
                    // Adjectives
                    'f' => ['Negra|s', 'Sórdida|s', 'Sangrienta|s', 'Muerta|s', 'Desolada|s', 'Abandonada|s', 'Pútrida|s', 'Desierta|s', 'Condenada|s', 'Oscura|s', 'Escondida|s', 'Sucia|s', 'Enterrada|s', 'Perdida|s', 'Desaparecida|s', 'Sepultada|s', 'Pálida|s', 'Mugrosa|s', 'Macabra|s', 'Desgraciada|s', 'Desdichada|s', 'Afligida|s', 'Pesarosa|s', 'Mustia|s', 'Taciturna|s', 'Funesta|s', 'Tétrica|s', 'Trágica|s', 'Siniestra|s', 'Apagada|s', 'Mala|s', 'Desastrosa|s', 'Ruda|s', 'Bárbara|s', 'Dura|s', 'Despiadada|s', 'Inhumana|s', 'Sanguinaria|s', 'Violenta|s', 'Tormentosa|s', 'Villana|s', 'Loca|s', 'Nostálgica|s', 'Retrógrada|s', 'Rancia|s', 'Arcáica|s', 'Caduca|s', 'Anticuada|s', 'Melancólica|s', 'Perversa|s', 'Maligna|s', 'Infectada|s', 'Gangrenada|s', 'Festiva|s', 'Agrietada|s', 'Contaminada|s', 'Paralizada|s', 'Fría|s', 'Risueña|s', 'Jocosa|s', 'Iracunda|s', 'Colérica|s', 'Corrupta|s', 'Despótica|s', 'Árida|s', 'Desequilibrada|s', 'Anecdótica|s', 'Patética|s', 'Protegida|s', 'Aislada|s', 'Morada|s', 'Roja|s', 'Maldita|s', 'Mohosa|s', 'Desamparada|s', 'Abatida|s', 'Extraña|s', 'Austera|s', 'Psicótica|s', 'Tensa|s', 'Crítica|s', 'Nefasta|s', 'Funesta|s', 'Dichosa|s', 'Próspera|s', 'Venturosa|s', 'Remota|s', 'Antigua|s', 'Nueva|s', 'Baja|s', 'Alta|s', 'Seca|s', 'Redonda|s', 'Áspera|s', 'Chica|s', 'Hedionda|s', 'Insípida|s', 'Telúrica|s', 'Ridícula|s', 'Cisañosa|s', 'Inmunda|s', 'Grotesca|s', 'Telúrica|s'],
                    'm' => ['Negro|s', 'Sórdido|s', 'Sangriento|s', 'Muerto|s', 'Desolado|s', 'Abandonado|s', 'Pútrido|s', 'Desierto|s', 'Condenado|s', 'Oscuro|s', 'Escondido|s', 'Sucio|s', 'Enterrado|s', 'Perdido|s', 'Desaparecido|s', 'Sepultado|s', 'Pálido|s', 'Mugroso|s', 'Macabro|s', 'Desgraciado|s', 'Desdichado|s', 'Afligido|s', 'Pesaroso|s', 'Mustio|s', 'Taciturno|s', 'Funesto|s', 'Tétrico|s', 'Trágico|s', 'Siniestro|s', 'Apagado|s', 'Malo|s', 'Desastroso|s', 'Rudo|s', 'Bárbaro|s', 'Duro|s', 'Despiadado|s', 'Inhumano|s', 'Sanguinario|s', 'Violento|s', 'Tormentoso|s', 'Villano|s', 'Loco|s', 'Nostálgico|s', 'Retrógrado|s', 'Rancio|s', 'Arcáico|s', 'Caduco|s', 'Anticuado|s', 'Melancólico|s', 'Perverso|s', 'Maligno|s', 'Infectado|s', 'Gangrenado|s', 'Festivo|s', 'Agrietado|s', 'Contaminado|s', 'Paralizado|s', 'Frío|s', 'Risueño|s', 'Jocoso|s', 'Iracundo|s', 'Colérico|s', 'Corrupto|s', 'Despótico|s', 'Árido|s', 'Desequilibrado|s', 'Anecdótico|s', 'Patético|s', 'Protegido|s', 'Aislado|s', 'Morado|s', 'Rojo|s', 'Maldito|s', 'Mohoso|s', 'Desamparado|s', 'Abatido|s', 'Extraño|s', 'Austero|s', 'Psicótico|s', 'Tenso|s', 'Crítico|s', 'Nefasto|s', 'Funesto|s', 'Dichoso|s', 'Próspero|s', 'Venturoso|s', 'Remoto|s', 'Antiguo|s', 'Nuevo|s', 'Bajo|s', 'Alto|s', 'Seco|s', 'Redondo|s', 'Áspero|s', 'Chico|s', 'Hediondo|s', 'Insípido|s', 'Telúrico|s', 'Ridículo|s', 'Cisañoso|s', 'Inmundo|s', 'Grotesco|s', 'Telúrico|s'],
                    '*' => ['Deprimente|s', 'Caliente|s', 'Alegre|s', 'Radiante|s', 'Ardiente|s', 'Desagradable|s', 'Fúnebre|s', 'Triste|s', 'Deplorable|s', 'Lamentable|s', 'Grave|s', 'Lúgubre|s', 'Mediocre|s', 'Repugnante|s', 'Salvaje|s', 'Implacable|s', 'Agreste|s', 'Infame|s', 'Grande|s', 'Detestable|s'],
                ],
                [
                    // Suffixes
                    'f' => [ ],
                    'm' => [ ],
                    '*' => ['de Angustia|s', 'del Ojo Triste|<de los Ojos Tristes', 'de los Guardianes', 'de los Desaparecidos', 'de la Luz', 'del Gran Poder', 'de la Esperanza|s', 'del Socorro|s', 'del Pez Rabioso|s', 'de Sol Divino|s', 'del Oro Azul|s', 'de Ensueño|s', 'de la Epidemia|s', 'de Deepnight|s', 'del Caballo Blanco', 'del Morro Solar|s', 'del Camino Sinuoso|s', 'de los Topos', 'del Ave Mensajera|s', 'de los Mártires', 'del Humo Negro|s', 'del Espectro Verde|s', 'del Terrible Susto|s', 'del Mago|s', 'del Arquitecto Orate|s', 'del Chiste Malo|s', 'del Ingenio|s', 'de la Gran Mentira|s', 'del Gran Susto|s', 'del Héroe Olvidado|s', 'de la Luna|s', 'de los Ídolos', 'de los Ancestros Mayas', 'de la Injusticia|s', 'del Gran Guía|s', 'del Sueño Inspirador|s', 'del Cuervo Loco|s', 'del Grito Ahogado|s', 'del Troll Fantasma|s', 'de los Eclipses', 'del Punto Rojo', 'de Maestro Shaolín|s', 'del Poeta Solitario|s', 'del Espasmo|s', 'de la Justicia|s', 'de los Tuertos', 'del Nunca Jamás', 'de la Verdad Absoluta|s', 'de los Renegados', 'de los Lamentos', 'del Socorro|s', 'de la Lluvia Perpetua|s', 'del Veneno Vil|s', 'de la Paz|s', 'de Carroñeros', 'de la Astucia|s', 'de los Caporales', 'del Antídoto|s', 'de Carne Débil|s', 'del Por Qué|s', 'del Mal Menor|s', 'del Delirium Tremens', 'de los Pasos Perdidos', 'de los Temblores', 'del Ojo Ciego|s', 'del Quinto Elemento|s', 'de la Legión Púrpura|s', 'del Futuro Incierto|s', 'del Guante Caído|s', 'del Pasado Brillante|s', 'de Sagitario|s', 'de Géminis', 'de Capricornio|s', 'de Aries', 'de Tauro|s', 'de la Juventud|s', 'del Olvido|s', 'de la Amargura|s', 'del Alma Pura|s', 'de los Brazos Cruzados', 'de Fuego|s', 'del Gran Jefe|s', 'del Pequeño Saltamontes', 'del Hambre|s', 'de lo Perverso|s', 'de la Tranquilidad|s', 'de la Utopía|s', 'de Sabiduría|s', 'de la Independencia|s', 'del Profeta|s', 'del Primer Instinto|s', 'de la Brisa Fétida|s', 'del Pensamiento|s', 'de la Piel Cobriza|s', 'de los Bipolares', 'del Embrujo|s', 'del Dolor|s', 'del Rey Cuervo|s', 'del Optimismo|s', 'del Pesimismo|s', 'de lo Desconocido|s', 'de la Peste Negra|s', 'del Deseo Inútil|es', 'de la Razón|es', 'del Sentido Común|s', 'de la Hermandad|s', 'del Pacífico|s', 'de la Caridad|s', 'de la Alegría|s', 'de Murakami|s', 'del Instinto Carnal|s', 'de los Descosidos', 'de los Descalzos', 'del Amor Interesado|s', 'de la Risa Contagiante|s', 'de Lágrimas Ajenas', 'de Sangre Caliente|s', 'del Fracaso|s', 'del Miedo|s', 'de Tripas Secas', 'de los Milagros', 'de Atacama|s', 'de Baja California|s', 'de Sonora|s', 'de Sechura|s', 'de Paita|s', 'de Paracas', 'de Nazca|s', 'de Tabernas', 'de Badenas Reales', 'de Monegros', 'de Guajira|s', 'de la Esmeralda|s', 'Sin Mañana|s', 'de la Tierra del Fuego|s', 'de la Patagonia|s', 'del Carnaval|s', 'Sin Fin|s', 'de los Condenados', 'del Norte|s', 'del Sur|s', 'del Este|s', 'del Oeste|s', 'del Oriente|s', 'de Virgo|s', 'de los Últimos Héroes', 'de Orión|s', 'del Fin del Mundo|s', 'del Buen Tiempo|s', 'de la Esperanza|s', 'del Crimen Impune|s', 'del Castigo|s', 'de Corazones', 'de Mil Lágrimas', 'del Nosequé|s', 'de Kalahari|s', 'de Teneré|s', 'del Ecuador|s', 'del Gran Poder|s', 'del Otoño|s', 'del Cielo Prometido|s', 'del Sarcasmo|s', 'de Cárcamo Díaz|s', 'del Díscolo|s', 'de San Pedro|s', 'de San Pablo|s', 'de San Mateo|s', 'de San Quintín|s', 'de Judas', 'de Don Ramón|es', 'de Changó|s', 'de la Santería|s', 'de los Babasónicos', 'del Sadismo|s', 'del Silencio|s', 'del Apocalipsis', 'del Insomnio|s', 'de Cramberries', 'de los Habitantes Anónimos', 'del Cada Vez Peor|s', 'de Hendrix|s', 'de Nadie|s', 'de la Nada|s', 'de la Carcajada|<de las Carcajadas', 'del Colmo|s', 'del Pudor|s', 'del Único Camino|s', 'de la Ira|s', 'de Hard Rock|s', 'de la Redención|es', 'del Loco|s', 'de Traición|es', 'de los Rolling Stones', 'del Río Seco|s', 'del Cojo|s', 'de la Cachetada|s', 'del Calambre|s', 'de la Envidia|s', 'de la Gula|s', 'de la Avaricia|s', 'de la Soberbia|s', 'de Zombiepolares', 'del Yonofuí|s', 'del Queseyó|s', 'de Nosedonde|s', 'de Quiensabequé|s', 'de Malkev|s', 'de Ficachi|s', 'de Snow|s', 'de Binto|s', 'de Len Kagamine|s', 'de Aldesa|s', 'de Len Dragonick|s', 'de Amasijador|s', 'de H4RO', 'de Trendy|s', 'de Giar|s', 'de dunedain33', 'de Bossu|s', 'de Znarf', 'de LordLuis', 'de KamusDave', 'de AlancapoII', 'de Kraterfire', 'de Trendy', 'del Cuervo Loco'],
                ]
            ]
        ],
    ];

    private static array $town_mutator_snippets = [
        'halloween' => [
            'de' => [
                2 => [
                    // Suffixes
                    'f' => [ ],
                    'm' => [ ],
                    'n' => [ ],
                    '*' => ['der Kürbisse', 'aus den Kürbissen', 'aus Kürbis', 'aus Kürbissen', 'an Halloween', 'aus dem Kessel', 'der Hexen', 'der Hexe', 'am Fest der Toten', 'der tanzenden Toten', 'aus dem hohlen Kürbis'],
                ]
            ],
            'en' => [
                [2 => [ 'of pumpkins', 'of Halloween', 'of the cauldron', 'of the witch', 'of the festival of the dead', 'of the dancing dead', 'of the hollow pumpkin' ]]
            ],
            'fr' => [
                2 => [
                    // Suffixes
                    'f' => [ ],
                    'm' => [ ],
                    '*' => ['des citrouilles', 'aux citrouilles', 'du potiron', 'aux potimarrons', 'd\'Halloween', 'du chaudron', 'aux sorcières', 'de la sorcière', 'de la fête des morts', 'des morts qui dansent', 'de la citrouille creuse'],
                ]
            ],
            'es' => [],
        ]
    ];

    private function pluralize(string $expression, bool $pluralize = true) {
        if (!$pluralize) return explode( '|', $expression )[0];

        [$word, $generator] = explode( '|', "$expression|" );
        while (!empty($generator)) {
            $char = mb_substr( $generator, 0, 1 );
            $generator = mb_substr( $generator, 1 );

            switch ($char) {
                case '-': $word = mb_substr( $word, 0, -1 ); break;
                case '<': $word = ''; break;
                default: $word .= $char; break;
            }
        }

        return $word;
    }

    private function getLangSelectionKeys(array $set, string $gender): array {
        return array_merge(
            array_map( fn(int $key) => "$gender.$key", array_keys( $set[$gender] ) ),
            array_map( fn(int $key) => "*.$key", array_keys( $set['*'] ) ),
        );
    }

    public function generateNameSchema(string $language, ?string $mutator = null): string {
        $data = static::$town_name_snippets[$language];

        if ($mutator && !isset( static::$town_mutator_snippets[$mutator] )) $mutator = null;
        $mutator_data = $mutator ? (static::$town_mutator_snippets[$mutator][$language] ?? []) : [];

        $conf_section = '?';

        switch ( $data['mode'] ) {

            case 'gsas':
                $gender = $this->random_generator->pick( $data['genders'] );
                $plural = $this->random_generator->chance( 0.5 );

                $conf_section = $gender . ($plural ? 'p' : 's');

                $mutator_keys = [];
                foreach ($data['sets'] as $index => &$set)
                    if (isset( $mutator_data[$index] )) {
                        $set = $mutator_data[$index];
                        $mutator_keys[] = $mutator;
                    } else $mutator_keys[] = null;
                unset ($set);

                // Example: [ '0.f.3', '1.*.9', '2.f.1' ]
                $name_set = array_map(
                    fn(array $set, int $index, ?string $mutator_key) => "$index." . $this->random_generator->pick( array_merge(
                        array_map( fn(int $key) => $mutator_key ? "$gender.$key!$mutator_key" : "$gender.$key", array_keys( $set[$gender] ) ),
                        array_map( fn(int $key) => $mutator_key ? "*.$key!$mutator_key" : "*.$key", array_keys( $set['*'] ) ),
                    ) ),
                    $data['sets'], array_keys($data['sets']), $mutator_keys
                );
                break;

            case 'combine':
                $base_set = $this->random_generator->pick( array_keys($data['sets'] ) );

                $conf_section = "$base_set";

                $mutator_keys = [];
                foreach ($data['sets'][$base_set] as $index => &$set)
                    if (isset( $mutator_data[$base_set][$index] )) {
                        $set = $mutator_data[$base_set][$index];
                        $mutator_keys[] = $mutator;
                    } else $mutator_keys[] = null;
                unset($set);

                // Example: [ '0.3', '1.9', '1.1' ]
                $name_set = array_map(
                    fn(array $set, int $index, ?string $mutator_key) => $mutator_key
                        ? "$index.{$this->random_generator->pick( array_keys($set) )}!$mutator_key"
                        : "$index.{$this->random_generator->pick( array_keys($set) )}"
                    , $data['sets'][$base_set], array_keys( $data['sets'][$base_set] ), $mutator_keys );
                break;

            default:
                $name_set = ['0'];
                break;
        }

        $opt = $mutator ? 'all' : $data['opt'];
        return "$language;{$data['mode']};$conf_section;" . match( $opt ) {
            'opt-last'  => implode(",", array_slice( $name_set, 0, $this->random_generator->chance(0.8) ? 2 : 3 )),
            'fix-first' => implode(",", $this->random_generator->chance(0.8) ? [ $name_set[0], $name_set[ $this->random_generator->pick([1,2]) ] ] : $name_set ),
            'fix-mid'   => implode(",", $this->random_generator->chance(0.8) ? array_slice( $name_set, $this->random_generator->pick([0,1]), 2 ) : $name_set ),
            'all'       => implode(",", $name_set),
        };
    }

    public function evaluateNameSchema(string $schema, bool $as_array = false): string|array|null {
        [$language,$mode,$config,$data] = explode( ';', $schema, 4 );
        $sections = explode(',', $data);

        if (!($data = static::$town_name_snippets[$language] ?? null)) return null;
        if ($data['mode'] !== $mode) return null;

        $name_sections = [];

        switch ($mode) {
            case 'gsas':
                if (mb_strlen( $config ) !== 2) return null;
                if (!in_array( mb_substr( $config, 1 ), ['p','s'] )) return null;

                $plural = mb_substr( $config, 1 ) === 'p';

                foreach ($sections as $section) {
                    [$access,$mutator] = explode( '!', "$section!" );
                    [$section_index,$key,$index] = explode( '.', $access, 3 );

                    if ($mutator && !isset( static::$town_mutator_snippets[$mutator][$language][$section_index] )) return null;
                    elseif ($mutator) $data['sets'][$section_index] = static::$town_mutator_snippets[$mutator][$language][$section_index];

                    if (
                        !isset( $data['sets'][$section_index] ) ||
                        !isset( $data['sets'][$section_index][$key] ) ||
                        !isset( $data['sets'][$section_index][$key][$index] )
                    ) return null;

                    $name_sections[] = $this->pluralize( $data['sets'][$section_index][$key][$index], $plural );
                }
                break;
            case 'combine':
                if (!is_numeric( $config )) return null;
                $set = (int)$config;

                if (!isset( $data['sets'][$set] )) return null;

                foreach ($sections as $section) {
                    [$access,$mutator] = explode( '!', "$section!" );
                    [$section_index,$index] = explode( '.', $access, 2 );

                    if ($mutator && !isset( static::$town_mutator_snippets[$mutator][$language][$set][$section_index] )) return null;
                    elseif ($mutator) $data['sets'][$set][$section_index] = static::$town_mutator_snippets[$mutator][$language][$set][$section_index];

                    if (
                        !isset( $data['sets'][$set][$section_index] ) ||
                        !isset( $data['sets'][$set][$section_index][$index] )
                    ) return null;

                    $name_sections[] = $data['sets'][$set][$section_index][$index];
                }

                break;
            default:
                return null;
        }

        return empty($name_sections) ? null : ($as_array ? $name_sections : ucfirst( implode( ' ', $name_sections ) ));
    }

    public function createTownName(string $language, ?string &$schema = null, ?string $mutator = null): string {

        $langList = array_keys(static::$town_name_snippets);
        if($language == 'multi') {
            $key = array_rand($langList);
            $language = $langList[$key];
        }

        return $this->evaluateNameSchema( $schema = $this->generateNameSchema( $language, $mutator ) ) ?? 'TOWN_NAME_GENERATOR_FAILED';
    }

    private function getDefaultZoneResolution( TownConf $conf, ?int &$offset_x, ?int &$offset_y ): int {
        $resolution = mt_rand( $conf->get(TownConf::CONF_MAP_MIN, 0), $conf->get(TownConf::CONF_MAP_MAX, 0) );
        $safe_border = ceil($resolution * $conf->get(TownConf::CONF_MAP_MARGIN, 0.25));

        if ($safe_border >= $resolution/2) {
            $offset_x = mt_rand(floor(($resolution-1)/2), ceil(($resolution-1)/2));
            $offset_y = mt_rand(floor(($resolution-1)/2), ceil(($resolution-1)/2));
        } else {
            $offset_x = $safe_border + mt_rand(0, max(0,$resolution - 2*$safe_border));
            $offset_y = $safe_border + mt_rand(0, max(0,$resolution - 2*$safe_border));
        }

        return $resolution;
    }

    public function createTown( ?string $name, ?string $language, ?int $population, string|array $type, $customConf = [], int $seed = -1, ?string $nameMutator = null ): ?Town {
        if (is_array( $type )) {
            $deriveFrom = $type[1] ?? $type[0];
            $type = $type[0];
        } else $deriveFrom = $type;

        if (!$this->validator->validateTownType($type))
            return null;

        if ($seed > 0) mt_srand($seed);

        $townClass = $this->entity_manager->getRepository(TownClass::class)->findOneBy([ 'name' => $type ]);

        // Initial: Create town
        $town = new Town();
        $town
            ->setType($townClass)
            ->setConf($customConf);

        if ($deriveFrom !== $type)
            $town->setDeriveConfigFrom( $deriveFrom );

        $currentSeason = $this->entity_manager->getRepository(Season::class)->findOneBy(['current' => true]);

        $town->setSeason($currentSeason);

        $conf = $this->conf->getTownConfiguration($town);

        if ($population === null) $population = mt_rand( $conf->get(TownConf::CONF_POPULATION_MIN, 0), $conf->get(TownConf::CONF_POPULATION_MAX, 0) );
        if ($population <= 0 || $population < $conf->get(TownConf::CONF_POPULATION_MIN, 0) || $population > $conf->get(TownConf::CONF_POPULATION_MAX, 0))
            return null;

        $this->translator->setLocale($language ?? 'de');

        $schema = null;
        $town
            ->setPopulation( $population )
            ->setName( $name ?: $this->createTownName($language, $schema, $nameMutator) )
            ->setNameSchema( $schema )
            ->setLanguage( $language )
            ->setBank( new Inventory() )
            ->setWell( mt_rand( $conf->get(TownConf::CONF_WELL_MIN, 0), $conf->get(TownConf::CONF_WELL_MAX, 0) ) );

        foreach ($this->entity_manager->getRepository(BuildingPrototype::class)->findProspectivePrototypes($town, 0) as $prototype)
            if (!in_array($prototype->getName(), $conf->get(TownConf::CONF_DISABLED_BUILDINGS))) {
                $this->town_handler->addBuilding($town, $prototype);
                $this->gps->recordBuildingDiscovered( $prototype, $town, null, 'always' );
            }

        $buildings_to_unlock = array_unique( array_merge( $conf->get(TownConf::CONF_BUILDINGS_UNLOCKED), $conf->get(TownConf::CONF_BUILDINGS_CONSTRUCTED) ) );
        $failed_unlocks = $last_failed_unlocks = 0;
        do {
            $last_failed_unlocks = $failed_unlocks;
            $failed_unlocks = 0;
            foreach ($buildings_to_unlock as $str_prototype)
                if (!in_array($str_prototype, $conf->get(TownConf::CONF_DISABLED_BUILDINGS))) {
                    $prototype = $this->entity_manager->getRepository(BuildingPrototype::class)->findOneBy(['name' => $str_prototype]);
                    if ($prototype) {
                        if ($this->town_handler->addBuilding($town, $prototype))
                            $this->gps->recordBuildingDiscovered( $prototype, $town, null, 'config' );
                        else $failed_unlocks++;
                    }
                }
        } while ($failed_unlocks > 0 && $failed_unlocks !== $last_failed_unlocks);


        foreach ($conf->get(TownConf::CONF_BUILDINGS_CONSTRUCTED) as $str_prototype) {
            if (in_array($str_prototype, $conf->get(TownConf::CONF_DISABLED_BUILDINGS)))
                continue;

            /** @var BuildingPrototype $proto */
            $proto = $this->entity_manager->getRepository(BuildingPrototype::class)->findOneBy( ['name' => $str_prototype] );
            $b = $this->town_handler->addBuilding( $town, $proto );
            $b->setAp( $proto->getAp() )->setComplete( true )->setHp($proto->getHp());
            $this->gps->recordBuildingConstructed( $proto, $town, null, 'config' );
        }

        $this->town_handler->calculate_zombie_attacks( $town, 3 );

        $defaultTag = $this->entity_manager->getRepository(ZoneTag::class)->findOneBy(['ref' => ZoneTag::TagNone]);

        $map_resolution = $this->getDefaultZoneResolution( $conf, $ox, $oy );
        for ($x = 0; $x < $map_resolution; $x++)
            for ($y = 0; $y < $map_resolution; $y++) {
                $zone = new Zone();
                $zone
                    ->setX( $x - $ox )
                    ->setY( $y - $oy )
                    ->setDigs( mt_rand( $conf->get(TownConf::CONF_ZONE_ITEMS_MIN, 5), $conf->get(TownConf::CONF_ZONE_ITEMS_MAX, 10) ) )
                    ->setFloor( new Inventory() )
                    ->setDiscoveryStatus( ($x - $ox == 0 && $y - $oy == 0) ? Zone::DiscoveryStateCurrent : Zone::DiscoveryStateNone )
                    ->setZombieStatus( ($x - $ox == 0 && $y - $oy == 0) ? Zone::ZombieStateExact : Zone::ZombieStateUnknown )
                    ->setZombies( 0 )
                    ->setInitialZombies( 0 )
                    ->setStartZombies( 0 )
                    ->setTag($defaultTag)
                ;
                $town->addZone( $zone );
            }

        $spawn_ruins = $conf->get(TownConf::CONF_NUM_RUINS, 0);

        $ruin_km_range = [
            $this->entity_manager->getRepository(ZonePrototype::class)->findMinRuinDistance(false),
            $this->entity_manager->getRepository(ZonePrototype::class)->findMaxRuinDistance(false),
        ];

        /** @var Zone[] $zone_list */
        $zone_list = array_filter($town->getZones()->getValues(), function(Zone $z) use ($ruin_km_range) {
            $km = round(sqrt( pow($z->getX(),2) + pow($z->getY(),2) ) );
            // $ap = abs($z->getX()) + abs($z->getY());
            return $km != 0 && $km >= $ruin_km_range[0] && $km <= $ruin_km_range[1];
        });
        shuffle($zone_list);

        $previous = [];

        $co_location_cache = [];
        $cl_get = function(int $x, int $y) use (&$co_location_cache): int {
            $m = 0;
            for ($xo = -1; $xo <= 1; $xo++) for ($yo = -1; $yo <= 1; $yo++)
                if (isset($co_location_cache[$id = (($x+$xo) . '.' . ($y+$yo))]))
                    $m = max($m, count($co_location_cache[$id]));
            return $m;
        };
        $cl_set = function(int $x, int $y) use (&$co_location_cache): void {
            $a = [$x . '.' . $y];
            for ($xo = -1; $xo <= 1; $xo++) for ($yo = -1; $yo <= 1; $yo++)
                if (isset($co_location_cache[$id = (($x+$xo) . '.' . ($y+$yo))]))
                    $a = array_merge($a,$co_location_cache[$id]);
            $a = array_unique($a);
            foreach ($a as $id) $co_location_cache[$id] = $a;
        };

        $o = 0;
        for ($i = 0; $i < $spawn_ruins+2; $i++) {

            $zombies_base = 0;
            do {
                if (($i+$o) >= count($zone_list)) continue 2;
                $b = $cl_get( $zone_list[$i+$o]->getX(), $zone_list[$i+$o]->getY() );
                if ($b <= 1) $keep_location = true;
                else if ($b === 2) $keep_location = $this->random_generator->chance(0.25);
                else $keep_location = false;

                if (!$keep_location) $o++;
            } while ( !$keep_location );

            $cl_set( $zone_list[$i+$o]->getX(), $zone_list[$i+$o]->getY() );

            if ($i < $spawn_ruins) {

                $zombies_base = 1 + floor(min(1,sqrt( pow($zone_list[$i+$o]->getX(),2) + pow($zone_list[$i+$o]->getY(),2) )/18) * 18);

                //$ruin_types = $this->entity_manager->getRepository(ZonePrototype::class)->findByDistance( abs($zone_list[$i]->getX()) + abs($zone_list[$i]->getY()) );
                $ruin_types = $this->entity_manager->getRepository(ZonePrototype::class)->findByDistance(round(sqrt( pow($zone_list[$i+$o]->getX(),2) + pow($zone_list[$i+$o]->getY(),2) )));
                if (empty($ruin_types)) continue;

                $iterations = 0;
                do {
                    $target_ruin = $this->random_generator->pickLocationFromList( $ruin_types );
                    $iterations++;
                } while ( isset( $previous[$target_ruin->getId()] ) && $iterations <= $previous[$target_ruin->getId()] );

                if (!isset( $previous[$target_ruin->getId()] )) $previous[$target_ruin->getId()] = 1;
                else $previous[$target_ruin->getId()]++;

                $zone_list[$i+$o]
                    ->setPrototype( $target_ruin )
                    ->setRuinDigs( mt_rand( $conf->get(TownConf::CONF_RUIN_ITEMS_MIN, 10), $conf->get(TownConf::CONF_RUIN_ITEMS_MAX, 10) ) );

                if ($conf->get(TownConf::CONF_FEATURE_CAMPING, false))
                    $zone_list[$i+$o]->setBlueprint(Zone::BlueprintAvailable);

                if ($this->random_generator->chance(0.5)) $zone_list[$i+$o]->setBuryCount( mt_rand(6, 20) );
            } else
                if ($this->random_generator->chance(0.1))
                    $zombies_base = 1 + floor(min(1,sqrt( pow($zone_list[$i+$o]->getX(),2) + pow($zone_list[$i+$o]->getY(),2) )/18) * 3);

            if ($zombies_base > 0) {
                $zombies_base = max(1, mt_rand( floor($zombies_base * 0.8), ceil($zombies_base * 1.2) ) );
                $zone_list[$i+$o]->setZombies( $zombies_base )->setInitialZombies( $zombies_base );
            }
        }

        $spawn_explorable_ruins = $conf->get(TownConf::CONF_NUM_EXPLORABLE_RUINS, 0);
        $all_explorable_ruins = $explorable_ruins = [];
        if ($spawn_explorable_ruins > 0)
            $all_explorable_ruins = $this->entity_manager->getRepository(ZonePrototype::class)->findBy( ['explorable' => true] );
            $zone_list = array_filter($town->getZones()->getValues(), function(Zone $z) {return $z->getPrototype() === null && ($z->getX() !== 0 || $z->getY() !== 0);});

        for ($i = 0; $i < $spawn_explorable_ruins; $i++) {
            if (empty($explorable_ruins)) {
                $explorable_ruins = $all_explorable_ruins;
                shuffle($explorable_ruins);
            }

            /** @var ZonePrototype $spawning_ruin */
            $spawning_ruin = array_pop($explorable_ruins);
            if (!$spawning_ruin) continue;

            $maxDistance = $conf->get(TownConf::CONF_EXPLORABLES_MAX_DISTANCE, 100);
            $spawn_zone = $this->random_generator->pickLocationBetweenFromList($zone_list, $spawning_ruin->getMinDistance(), $maxDistance, ['prototype_id' => null]);

            if ($spawn_zone) {
                $spawn_zone->setPrototype($spawning_ruin);
                $this->maze_maker->createField( $spawn_zone, $conf->get(TownConf::CONF_EXPLORABLES_FLOORS, 1) );
                $this->maze_maker->generateCompleteMaze( $spawn_zone );

                $zombies_base = 1 + floor(min(1,sqrt( pow($spawn_zone->getX(),2) + pow($spawn_zone->getY(),2) )/18) * 3);
                $zombies_base = max(1, mt_rand( floor($zombies_base * 0.8), ceil($zombies_base * 1.2) ) );
                $spawn_zone->setZombies( $zombies_base )->setInitialZombies( $zombies_base );
            }
        }

        $item_spawns = $conf->get(TownConf::CONF_DISTRIBUTED_ITEMS, []);
        $distribution = [];

        $zone_list = $town->getZones()->getValues();
        foreach ($conf->get(TownConf::CONF_DISTRIBUTION_DISTANCE, []) as $dd) {
            $distribution[$dd['item']] = ['min' => $dd['min'], 'max' => $dd['max']];
        }
        for ($i = 0; $i < count($item_spawns); $i++) {
            $item = $item_spawns[$i];
            if (isset($distribution[$item])) {
                $min_distance = $distribution[$item]['min'];
                $max_distance = $distribution[$item]['max'];
            }
            else {
                $min_distance = 1;
                $max_distance = 100;
            }

            $spawnZone = $this->random_generator->pickLocationBetweenFromList($zone_list, $min_distance, $max_distance);
            if ($spawnZone) {
                $this->inventory_handler->forceMoveItem($spawnZone->getFloor(), $this->item_factory->createItem($item_spawns[$i]));
                $zone_list = array_filter( $zone_list, fn(Zone $z) => $z !== $spawnZone );
            }
        }

        $this->zone_handler->dailyZombieSpawn( $town, 1, ZoneHandler::RespawnModeNone );
        foreach ($town->getZones() as $zone) $zone->setStartZombies( $zone->getZombies() );

        $town->setForum((new Forum())->setTitle($town->getName()));
        foreach ($this->entity_manager->getRepository(ThreadTag::class)->findBy(['name' => ['help','rp','event','dsc_disc','dsc_guide','dsc_orga']]) as $tag)
            $town->getForum()->addAllowedTag($tag);

        $this->crow->postToForum( $town->getForum(),
            [
                T::__('In diesem Thread dreht sich alles um die Bank.', 'game'),
                T::__('In diesem Thread dreht sich alles um die geplanten Verbesserungen des Tages.', 'game'),
                T::__('In diesem Thread dreht sich alles um die Werkstatt und um Ressourcen.', 'game'),
                T::__('In diesem Thread dreht sich alles um zukünftige Bauprojekte.', 'game'),
            ],
            true, true,
            [
                T::__('Bank', 'game'),
                T::__('Verbesserung des Tages', 'game'),
                T::__('Werkstatt', 'game'),
                T::__('Konstruktionen', 'game')
            ],
            [
                Thread::SEMANTIC_BANK,
                Thread::SEMANTIC_DAILYVOTE,
                Thread::SEMANTIC_WORKSHOP,
                Thread::SEMANTIC_CONSTRUCTIONS
            ]
        );

        /** @var Gazette $gazette */
        $gazette = new Gazette();
        $gazette->setTown($town)->setDay($town->getDay());
        $town->addGazette($gazette);
        $this->entity_manager->persist($gazette);

        return $town;
    }

    public function userCanEnterTown( Town &$town, User &$user, bool $whitelist_enabled = false, ?int &$error = null, bool $internal = false ): bool {
        if (!$town->isOpen() || $town->getScheduledFor() > (new \DateTime())) {
            $error = self::ErrorTownClosed;
            return false;
        }

        if (!$internal && $this->user_handler->getConsecutiveDeathLock($user)) {
            $error = ErrorHelper::ErrorPermissionError;
            return false;
        }

        if (!$internal && !$this->conf->getTownConfiguration( $town )->get( TownConf::CONF_FEATURE_NO_SP_REQUIRED )) {
            $conf = $this->conf->getGlobalConf();
            $sp = $this->user_handler->fetchSoulPoints($user);
            $allowed = false;
            switch ($town->getType()->getName()) {
                case 'small':
                    $allowed = ($sp < $conf->get( MyHordesConf::CONF_SOULPOINT_LIMIT_REMOTE, 100 ) || $sp >= $conf->get( MyHordesConf::CONF_SOULPOINT_LIMIT_BACK_TO_SMALL, 500 ));
                    break;
                case 'remote':
                    $allowed = $sp >= $conf->get( MyHordesConf::CONF_SOULPOINT_LIMIT_REMOTE, 100 );
                    break;
                case 'panda':
                    $allowed = $sp >= $conf->get( MyHordesConf::CONF_SOULPOINT_LIMIT_PANDA, 500 );
                    break;
                case 'custom':
                    $allowed = $sp >= $conf->get( MyHordesConf::CONF_SOULPOINT_LIMIT_CUSTOM, 1000 );
                    break;
            }

            if (!$allowed && !$this->user_handler->checkFeatureUnlock( $user, 'f_sptkt', true )) {
                $error = ErrorHelper::ErrorPermissionError;
                return false;
            }
        }

        $whitelist = $whitelist_enabled ? $this->entity_manager->getRepository(TownSlotReservation::class)->findOneBy(['town' => $town, 'user' => $user]) : null;
        if ($whitelist_enabled && $whitelist === null && $user !== $town->getCreator()) {
            $error = ErrorHelper::ErrorPermissionError;
            return false;
        }

        if ($this->entity_manager->getRepository(Citizen::class)->findActiveByUser( $user ) !== null) {
            $error = self::ErrorUserAlreadyInGame;
            return false;
        }

        foreach ($town->getCitizens() as $existing_citizen)
            if ($existing_citizen->getUser() === $user) {
                $error = self::ErrorUserAlreadyInTown;
                return false;
            }

        return true;
    }

    public function createCitizen( Town &$town, User &$user, ?int &$error, ?array &$all_citizens = null, bool $internal = false ): ?Citizen {
        $error = self::ErrorNone;
        $lock = $this->locksmith->waitForLock('join-town');

        $whitelist_enabled = $this->entity_manager->getRepository(TownSlotReservation::class)->count(['town' => $town]) > 0;

        $followers = ($internal || $town->getPassword() || $whitelist_enabled) ? [] : $this->user_handler->getAvailableCoalitionMembers( $user );

        if (!$this->userCanEnterTown($town,$user, $whitelist_enabled,$error,$internal))
            return null;

        $followers = array_filter($followers, function (User $follower) use ($town,$whitelist_enabled,$internal): bool {
            return $this->userCanEnterTown($town,$follower,$whitelist_enabled,$e, $internal);
        });

        if (($town->getCitizenCount() + count($followers) + 1) > $town->getPopulation()) {
            $error = self::ErrorTownNoCoaRoom;
            return null;
        }

        $base_profession = $this->entity_manager->getRepository(CitizenProfession::class)->findDefault();
        if ($base_profession === null) {
            $error = self::ErrorNoDefaultProfession;
            return null;
        }

        $followers[] = $user;
        $main_citizen = null;
        $all_citizens = [];

        $town_group = $this->entity_manager->getRepository(UserGroup::class)->findOneBy( ['type' => UserGroup::GroupTownInhabitants, 'ref1' => $town->getId()] );

        $cx_clean_shoutbox_state = [];
        foreach ($followers as $joining_user)
            if ($sb = $this->user_handler->getShoutbox($joining_user)) {
                $last_entry = $this->entity_manager->getRepository(ShoutboxEntry::class)->findOneBy(['shoutbox' => $sb], ['timestamp' => 'DESC', 'id' => 'DESC']);
                if ($last_entry) {
                    $marker = $this->entity_manager->getRepository(ShoutboxReadMarker::class)->findOneBy(['user' => $joining_user]);
                    if ($marker && $last_entry === $marker->getEntry()) $cx_clean_shoutbox_state[] = $joining_user;
                }
            }

        $entry_cache = [];
        foreach ($followers as $joining_user) {

            $home = new CitizenHome();
            $home
                ->setChest( $chest = new Inventory() )
                ->setPrototype( $this->entity_manager->getRepository( CitizenHomePrototype::class )->findOneBy(['level' => 0]) )
            ;

            $joining_user->addCitizen( $citizen = new Citizen() );
            $citizen->setUser( $joining_user )
                ->setTown( $town )
                ->setInventory( new Inventory() )
                ->setHome( $home )
                ->setCauseOfDeath( $this->entity_manager->getRepository( CauseOfDeath::class )->findOneBy( ['ref' => CauseOfDeath::Unknown] ) )
                ->setHasSeenGazette( true );

            // Check for other coalition members
            foreach ($this->user_handler->getAllOtherCoalitionMembers( $joining_user ) as $coa_member) {
                $coa_citizen = $coa_member->getCitizenFor($town);
                if ($coa_citizen) {
                    $this->entity_manager->persist( $coa_citizen->setCoalized(true) );
                    $citizen->setCoalized( true );
                }
            }

            (new Inventory())->setCitizen( $citizen );
            $this->citizen_handler->inflictStatus( $citizen, 'clean' );

            if ($this->town_handler->getBuilding( $town, 'small_novlamps_#00' ))
                $this->citizen_handler->inflictStatus( $citizen, 'tg_novlamps' );

            $this->citizen_handler->applyProfession( $citizen, $base_profession );

            $this->inventory_handler->forceMoveItem( $chest, $this->item_factory->createItem( 'chest_citizen_#00' ) );
            $this->inventory_handler->forceMoveItem( $chest, $this->item_factory->createItem( 'food_bag_#00' ) );

            // Adding default heroic action
            $heroic_actions = $this->entity_manager->getRepository(HeroicActionPrototype::class)->findBy(['unlockable' => false]);
            foreach ($heroic_actions as $heroic_action)
                /** @var $heroic_action HeroicActionPrototype */
                $citizen->addHeroicAction( $heroic_action );

            if ($town_group) $this->perm->associate( $joining_user, $town_group );

            if ($joining_user === $user) $main_citizen = $citizen;
            $all_citizens[] = $citizen;
            $this->entity_manager->persist($citizen);

            /** @var Shoutbox|null $shoutbox */
            if ($shoutbox = $this->user_handler->getShoutbox($joining_user)) {
                $shoutbox->addEntry(
                    $entry_cache[$shoutbox->getId()] = (new ShoutboxEntry())
                        ->setType( ShoutboxEntry::SBEntryTypeTown )
                        ->setTimestamp( new \DateTime() )
                        ->setUser1( $joining_user )
                        ->setText( $town->getName() )
                );
                $this->entity_manager->persist($shoutbox);
            }
        }

        foreach ($cx_clean_shoutbox_state as $sb_clean_user)
            if ($sb = $this->user_handler->getShoutbox($sb_clean_user)) {

                if (isset($entry_cache[$sb->getId()])) {
                    /** @var ShoutboxReadMarker $marker */
                    $marker = $this->entity_manager->getRepository(ShoutboxReadMarker::class)->findOneBy(['user' => $sb_clean_user]);
                    if ($marker)
                        $this->entity_manager->persist($marker->setEntry( $entry_cache[$sb->getId()] ));
                }
            }

        $whitelist = $whitelist_enabled ? $this->entity_manager->getRepository(TownSlotReservation::class)->findOneBy(['town' => $town, 'user' => $user]) : null;
        if ($whitelist !== null) $this->entity_manager->remove($whitelist);

        return $main_citizen;
    }

    /**
     * @param Town|TownRankingProxy $town
     * @return void
     */
    public function updateTownScore(TownRankingProxy|Town $town, bool $resetDay = false): void {
        $score = 0;
        $lastDay = 0;

        $tr = null;
        if (is_a( $town, Town::class )) $tr = $town->getRankingEntry();
        elseif (is_a( $town, TownRankingProxy::class )) $tr = $town;

        foreach ($tr->getCitizens() as $r_citizen) {
            /* @var CitizenRankingProxy $citizen */
            $score += $r_citizen->getDay();
            $lastDay = max( $lastDay, $r_citizen->getDay());
        }

        if ($resetDay && is_a( $town, Town::class )) $town->setDay( $lastDay );
        $this->entity_manager->persist( $tr->setDays($lastDay)->setScore($score) );
    }

    public function compactTown(Town $town): bool {

        foreach ($town->getCitizens() as $citizen) if ($citizen->getAlive()) return false;
        if ($town->isOpen() && !$town->getCitizens()->isEmpty()) return false;

        $this->updateTownScore($town, true);
        $this->gps->recordTownEnded($town);
        $this->entity_manager->remove($town);
        return true;
    }

    public function nullifyTown(Town $town, bool $force = false): bool {
        if ($town->isOpen() && !$force) return false;

        if ($town->getRankingEntry()) $this->entity_manager->remove($town->getRankingEntry());
        $this->entity_manager->remove($town);
        return true;
    }

    public function enableStranger(Town $town): bool {
        if (!$town->isOpen()) return false;

        $town->setStrangerPower( $town->getPopulation() - $town->getCitizenCount() );
        $town->setPopulation( $town->getCitizenCount() );
        $this->entity_manager->persist( $town );
        $this->entity_manager->persist( $this->log->strangerJoinProfession( $town, $this->timeKeeper->getCurrentAttackTime()->sub(DateInterval::createFromDateString('2min'))));
        return true;
    }
}
